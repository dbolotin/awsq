#! /usr/bin/env python

import sys
import os
import argparse
from argparse import ArgumentError

import shlex
import boto3
import itertools
import hashlib
import cPickle as pickle
import io
import zlib

# importing subprocess or backport in python 2.x
from botocore.exceptions import ClientError

if os.name == 'posix' and sys.version_info[0] < 3:
    import subprocess32 as subprocess
else:
    import subprocess as sp


class Cmd:
    """ Represents command execution request. """

    def __init__(self, cmd, once_tag=None):
        self.cmd = cmd
        self.once_tag = once_tag

    def __repr__(self):
        if self.once_tag:
            return "Cmd{ %s ; once = %s }" % (self.cmd, self.once_tag)
        else:
            return "Cmd{ %s }" % self.cmd


class File:
    """ Represents job-message-embedded file. """

    def __init__(self, file_name, content):
        self.file_name = file_name
        self.content = content

    def __repr__(self):
        return "File{ %s, size=%s }" % (self.file_name, len(self.content))


#
# Arguments parser
#

# Python issue 27859 example workaround
class FixParserAction(argparse._SubParsersAction):
    def __call__(self, parser, namespace, values, option_string=None):
        parser_name = values[0]
        arg_strings = values[1:]

        # set the parser name if requested
        if self.dest is not argparse.SUPPRESS:
            setattr(namespace, self.dest, parser_name)

        # select the parser
        try:
            parser = self._name_parser_map[parser_name]
        except KeyError:
            args = {'parser_name': parser_name,
                    'choices': ', '.join(self._name_parser_map)}
            msg = _('unknown parser %(parser_name)r (choices: %(choices)s)') % args
            raise argparse.ArgumentError(self, msg)

        # parse all the remaining options into the namespace
        # store any unrecognized options on the object, so that the top
        # level parser can decide what to do with them

        # ORIGINAL
        namespace, arg_strings = parser.parse_known_args(arg_strings, namespace)

        # issue 9351 change
        ## In case this subparser defines new defaults, we parse them
        ## in a new namespace object and then update the original
        ## namespace for the relevant parts.
        # subnamespace, arg_strings = parser.parse_known_args(arg_strings, None)
        # for key, value in vars(subnamespace).items():
        #    setattr(namespace, key, value)

        if arg_strings:
            vars(namespace).setdefault(argparse._UNRECOGNIZED_ARGS_ATTR, [])
            getattr(namespace, argparse._UNRECOGNIZED_ARGS_ATTR).extend(arg_strings)


class QNamespace:
    """ Used to parse CLI arguments """

    def __init__(self):
        self.profile = None
        self.queue = None
        self.once = False
        self.commands = []
        self.variables_generator = []
        self.subcommand = None

    def reset_once(self):
        self.once = False

    def add_cmd(self, cmd, ignore_once=False):
        if ignore_once:
            self.commands.append(Cmd(cmd))
        else:
            self.commands.append(Cmd(cmd, self.get_once_tag(cmd)))
            self.reset_once()

    def add_file(self, l_file_name, r_file_name=None):
        if not r_file_name:
            r_file_name = l_file_name
        size = os.stat(l_file_name).st_size
        if size > 200000:
            raise argparse.ArgumentError(self, "File %s is too big to be "
                                               "attached to the job." % l_file_name)
        with open(l_file_name, 'r') as f:
            self.commands.append(File(r_file_name, f.read()))

    def set_once(self, once_tag):
        if once_tag:
            self.once = once_tag
        else:
            self.once = True

    def get_once_tag(self, content):
        once_tag = None
        if self.once:
            if self.once == True:
                once_tag = hashlib.md5(content).hexdigest()
            else:
                once_tag = self.once
        return once_tag


class OnceParserAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        namespace.set_once(values)


class CmdParserAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        namespace.add_cmd(values)


def variable_generator(dict):
    # Extracting variable / values form dict
    var_names = []
    var_values = []
    for key, value in dict.iteritems():
        var_names.append(key)
        var_values.append(value)

    # Output map function
    def to_dict(value_list):
        result = {}
        for i in range(len(value_list)):
            result[var_names[i]] = value_list[i]
        return result

    # Returning result
    return map(to_dict, itertools.product(*var_values))


class VariableParserAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        generators = []

        variables = {}
        for v in values:
            # New variable group start
            if v == '::':
                generators.append(variable_generator(variables))
                variables = {}
                continue

            eq_index = v.find('=')
            if eq_index == -1:
                raise ArgumentError(self, 'Variable "%s" contain no value.' % v)

            name = v[:eq_index]
            value = v[eq_index + 1:]

            if value == "-":
                value = "@map(lambda line: line[:-1], sys.stdin)"

            if value.startswith("@"):
                value = eval(value[1:])
            else:
                value = [value]

            variables[name] = value

        if variables:
            generators.append(variable_generator(variables))

        namespace.variables_generator = itertools.chain(*generators)


class FileParserAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        l_file_name = values
        r_file_name = values
        if ":" in l_file_name:
            spl = l_file_name.split(":")
            l_file_name = spl[0]
            r_file_name = spl[1]
        namespace.add_file(l_file_name, r_file_name)


class ExecuteParserAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        namespace.add_file(values)
        namespace.add_cmd("chmod +x " + values)
        namespace.add_cmd("./" + values)


# def publish_log(message, stderr):
#     print(message)
#
#
# def process_message(message):
#
#
# def process_message(message):
#     if message.startswith('{') or message.startswith('"') or message.startswith('['):


# def execute(args):
#     resp = sqs_client.receive_message(QueueUrl=queue_url, MaxNumberOfMessages=1, VisibilityTimeout=10,
#                                       WaitTimeSeconds=20)
#     resp["Messages"]
#     print resp


# with subprocess.Popen("sleep 10;", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
#     outs, errs = proc.communicate(timeout=5)
#     print("OUTS: " + outs)
#     print("ERRS: " + errs)


# Creating arg parser

# Create the top-level parser
main_parser = argparse.ArgumentParser(prog='awsq')

# chg which Action class is used for subparsers
main_parser.register('action', 'parsers', FixParserAction)

main_parser.add_argument('--queue', help='SQS queue name')
main_parser.add_argument('--profile', help='AWS Credentials profile')
# parser.add_argument('--create-queue', help='Create SQS queue if not exists')
subparsers = main_parser.add_subparsers(help='sub-command help')

# "execute" subcommand
parser_execute = subparsers.add_parser('execute', help='executes command from the queue (must be started on '
                                                       'execution node)')
# parser_execute.set_defaults(subcommand="execute")

# "submit" subcommand
parser_submit = subparsers.add_parser('submit', help='pushes new command to queue')
parser_submit.add_argument('--cmd', help='Command', action=CmdParserAction)
parser_submit.add_argument('--attach',
                           help='Attach small file to job (e.g. script, config file, etc...). '
                                'File will be placed to working directory. To specify other '
                                'remote filename of the file use colon symbol, e.g. '
                                '"local_file_name.txt:remote_file.cfg").',
                           action=FileParserAction)
parser_submit.add_argument('--execute', help='Attach executable file to job and execute it on execution node.',
                           action=ExecuteParserAction)
parser_submit.add_argument('--once', nargs='?', help='Command', action=OnceParserAction)

parser_submit.add_argument('vars', metavar='VAR=value', nargs='*',
                           help='Variable value / values. Will be parsed using python\'s '
                                'eval(...) function.',
                           action=VariableParserAction)

# parser_submit.set_defaults(subcommand="submit")

# Parsing args
args = main_parser.parse_args(namespace=QNamespace())

# Creating boto3 clients
# session = boto3.Session(profile_name=args.profile)
# sqs_client = session.client('sqs')
#
# # Getting queue URL
# try:
#     response = sqs_client.get_queue_url(QueueName=args.queue)
#     queue_url = response["QueueUrl"]
# except ClientError as e:
#     if "NonExistentQueue" in e.response["Error"]["Code"]:
#         print("No queue with name: " + args.queue)
#     else:
#         print("Error while retrieving queue url.")
#         print(e.response)
#     exit(1)
#
# if args.subcommand == "submit":
#     resp = sqs_client.send_message(QueueUrl=queue_url, MessageBody=args.job)
#     print resp
#
# elif args.subcommand == "execute"
# # parser_a.add_argument('--idle-timeout', type=int, help='number of seconds after which this process will be '
# #                                                        'terminated if not receive new jobs')


# args = parser.parse_args("--execute gg.sh --cmd sd --once --cmd gogo --cmd sd --once asdf --cmd gogo".split(),
#                          namespace=QNamespace())

for c in args.commands:
    print(c)

for c in args.variables_generator:
    print(c)
